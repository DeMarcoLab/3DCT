#!/usr/bin/env python
"""
Contains functions often used in the scripts of this directory

$Id$
Author: Vladan Lucic 
"""
__version__ = "$Revision$"

# ToDo: see if this should become a superclass for some of the scripts

import sys
import os
import os.path
import time
import platform
import pickle
import logging

import pyto
import pyto.util.attributes as attributes


##################################################
#
# File name related
#

def get_file_base(file_):
    """
    Returns base and root of the image file name
    """
    (dir, base) = os.path.split(file_)
    (root, ext) = os.path.splitext(base)
    return base, root

def format_param(value=None, name='', format=None):
    """
    Makes parameter strings to be used for file names.

    Arguments:
      - value: parameter value
      - name: parameter name
      - format: parameter format
    """

    if value is not None:
        value_str = (format % value).strip()
        value_long_str = name + value_str
    else:
        value_str = ''
        value_long_str = ''

    return value_str, value_long_str

def make_file_name(directory='', prefix='', insert_root=True, 
                   reference=None, param_name='', param_value=None, 
                   param_format=None, suffix=''):
    """
    Returns a labels file name of the form:

      <directory> / <prefix> + reference_base + formated_param + <suffix>

    where: 
      - reference_base: arg reference without the directory and extension parts
      obtained by self.format_param(), added if arg insert_root is True
      - formated_param: formated parameter value obtained using 
      self.format_param()

    Arguments:
      - directory: directory
      - prefix: file name prefix
      - insert_root: insert reference file root in the file name
      - reference: reference file name
      - param_name: name of the parameter
      - param_value: value of a parameter to be inserted in the name
      - param_format: parameter value format
      - suffix: file name suffix
    """

    # format parameter
    value_str, value_long_str = format_param(value=param_value, name=param_name,
                                             format=param_format)

    # extract root from the reference file
    ref_base, root = get_file_base(reference)

    if insert_root:
        base = prefix + root + value_long_str + suffix
    else:
        base = prefix + value_long_str + suffix
    file_name = os.path.join(directory, base)

    return file_name
    
def is_multi_file(file_name):
    """
    Returns True if maultiple files are given.

    Argument:
      - file_name: one file name or a list (tuple) of file names
    """
    if isinstance(file_name, (str, unicode)):
        return False
    elif isinstance(file_name, tuple) or isinstance(file_name, list):
        return True
    else:
        raise ValueError(str(file_name) + " has to be either a string / unicode"
                         + " (one file) or a tuple (multiple files).")    

##################################################
#
# Writting result files
#

def machine_info():
    """
    Returns machine name and machine architecture strings
    """
    mach = platform.uname() 
    mach_name = mach[1]
    mach_arch = str([mach[0], mach[4], mach[5]])

    return mach_name, mach_arch

def format_file_info(name, description, ids=None, extra=''):
    """
    Returns a list of string(s) containing file, description and file creation
    time. Works also if more than one name is given. If arg ids is specified
    ids are added too.
    
    Arguments:
      - name: file name
      - description: file description
      - ids: ids
      - extra: other info
    """

    if name is None: return []

    if is_multi_file(file_name=name):

        # multi file
        lines = ["# " + description + ":"]
        try:
            file_time = time.asctime(time.localtime(os.path.getmtime(one_name)))
        except OSError:
            file_time = 'not written'
        lines.extend(["#     " + one_name + " (" + file_time + ")"
                      for one_name in name])
        if ids is not None:
            lines.extend(["#     Ids:" + str(ids)])

    else:

        # single_file
        try:
            file_time = time.asctime(time.localtime(os.path.getmtime(name)))
        except OSError:
            file_time = 'not written'
        lines = [("# " + description + ": " + name + " (" + file_time + ")" 
                  + extra)] 

    return lines

##################################################
#
# Writting data files
#

def write_labels(labels, name, data_type, inset=False):
    """
    Writes labels as an array.

    Arguments:
      - labels: (Labels) labels object (e.g. segmentation)
      - name: labels file name
      - data_type: data type
      - inset: the data is repositioned to this inset, if None labels.data 
      array is written without repositioning
    """

    # expand if needed
    init_inset = labels.inset
    if inset is not None:
        labels.useInset(inset=inset, mode='abs', expand=True)

    # see about adjusting the data type if needed

    # write
    labels.write(file=name, dataType=data_type)

    # revert to the original inset
    if inset is not None:
        labels.useInset(inset=init_inset, mode='abs')

##################################################
#
# Pickle files
#

def write_pickle(obj, file_name, image=[], compact=[]):
    """
    Pickles (and writes) large objects.

    Images specified by arg image are reduced to smallest insets and 
    objects specified in arg compact are compactified.

    Arguments:
      - obj: object to be pickled
      - file_name: pickle file name
      - image: list of names of attribute holding images (can be attributes of
      ... of objects)
      - compact: list of names of attribute that should be compactified (can
      be attributes of ... of objects)
    """

    # compactify contacts
    for c_name in compact:
        contacts = attributes.getattr_deep(obj, c_name)
        contacts.compactify()

    # reduce data size
    full_insets = []
    for image_name in image:
         image_obj = attributes.getattr_deep(obj, image_name)
         full_insets.append(image_obj.inset)
         image_obj.makeInset()

    # write 
    out_file = open(file_name, 'wb')
    pickle.dump(obj, out_file, -1)

    # expand 
    for c_name in compact:
        compact_obj = attributes.getattr_deep(obj, c_name)
        compact_obj.expand()

    # recover image insets
    for image_name, inset in zip(image, full_insets):
        image_obj = attributes.getattr_deep(obj, image_name)
        image_obj.useInset(inset=inset, mode='abs', useFull=True, expand=True)
    
def read_pickle(file_name, compact=[], inset=None, image=[]):
    """
    Reads pickles

    If arg inset is specified, images specified by arg image are brought to
    the given inset. Objects specified in arg compact are expanded.

    Arguments:
      - file_name: pickle file name
      - image: list of names of attribute holding images (can be attributes of
      ... of objects)
      - compact: list of names of attribute that should be expanded (can
      be attributes of ... of objects)

    Returns: unpickled object
    """

    # unpickle
    obj = pickle.load(open(file_name))

    # expand
    for c_name in compact:
        compact_obj = attributes.getattr_deep(obj, c_name)
        compact_obj.expand()

    # bring images to inset
    if inset is not None:
        for image_name in image:
            image_obj = attributes.getattr_deep(obj, image_name)        
            image_obj.useInset(inset=inset, mode='abs', 
                               useFull=True, expand=True)

    return obj
