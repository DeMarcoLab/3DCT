"""
Contains class Affine2D for preforming affine transformation (general linear
transformation followed by translation) on points (vectors) in 2D.

# Author: Vladan Lucic (Max Planck Institute for Biochemistry)
# $Id$
"""

__version__ = "$Revision$"


import logging
import numpy
import scipy
import scipy.linalg as linalg

from points import Points
from affine import Affine

class Affine2D(Affine):
    """
    Finds and preforms affine transformation (general linear transformation
    followed by translation) on points (vectors) in 2D.

    The transformation that transforms points x to points y has the following 
    form:

      y = gl x + d

    where:

      gl = q s p m

    Main methods:

      - find: finds a transformation between two sets of points
      - transform: transforms a (set of) point(s)
      - inverse: calculates inverse transformation
      - compose: composition of two transformations

    Important attributes and properties (see formulas above):

      - d: translation vector
      - gl: general linear transformation matrix
      - q: rotation matrix
      - phi: rotational angle (radians)
      - phiDeg: rotational angle (degrees)
      - s: scaling matrix (diagonal)
      - scale: vector of scaling parameters (diagonal of s)
      - p: parity matrix (diagonal)
      - parity: parity (+1 or -1)
      - m: shear matrix (upper-triangular)
      - error: error of transformation for all points
      - rmsError: root mean square error of the transformation
    """

    def __init__(self, d=None, gl=None, phi=None, scale=None, 
                 parity=1, shear=0, order=None):
        """
        Initialization. Following argument combinations are valid:
          - no arguments: no transformation matrices are initialized
          - d and gl: d and gl are set
          - d, phi and scale (parity and shear optional): d and gl 
          (gl = q p s m) are set
        """

        if (gl is not None) and (d is not None):
            super(self.__class__, self).__init__(gl, d)

        elif (phi is not None) and (scale is not None) and (d is not None):
            
            qp = numpy.inner(self.getQ(phi), self.getP(parity))
            sm = numpy.inner(self.getS(scale), self.getM(shear))
            gl = numpy.inner(qp, sm)
            super(self.__class__, self).__init__(gl, d)

    @classmethod
    def identity(cls):
        """
        Returnes an identity object of this class, that is a transformation 
        that leaves all vectors invariant.
        """
        super(self.__class__, self).identity(ndim=2)
        
    @classmethod
    def downcast(cls, affine):
        """
        Returns instance of this class that was obtained by dowoncasting
        art affine (instance of Affine, base class of this class).
        
        Argument:
          - affine: instance of Affine
        """

        # copy gl and d, obligatory
        new = cls(gl=affine.gl, d=affine.d)

        # copy attributes that are not obligarory
        for name in ['resids', 'rank', 'singular', 'error', '_xPrime', 
                     '_yPrime', 'q', 'p', 's', 'm']:
            try:
                value = getattr(affine, name)
                setattr(new, name, value)
            except AttributeError:
                pass
                
        return new

    ##############################################################
    #
    # Parameters
    #

    def getPhi(self):
        """
        Rotation angle of matrix self.q in radians.
        """
        #try:
        #    qq = self.q
        #except AttributeError:
        #    self.decompose(order='qpsm')
        res = numpy.arctan2(self.q[1,0], self.q[0,0])
        return res

    def setPhi(self, phi):
        """
        Sets transformation matrices related to phi (q and gl). Matrix gl is
        calculated using the current values of other matrices (p, s and m).
        """
        self.q = self.getQ(phi)
        try:
            gg = self.gl
            self.gl = self.composeGl()
        except AttributeError:
            pass

    phi = property(fget=getPhi, fset=setPhi, doc='Rotation angle in radians')

    def getPhiDeg(self):
        """
        Rotation angle in degrees
        """
        res = self.phi * 180 / numpy.pi
        return res

    phiDeg = property(fget=getPhiDeg, doc='Rotation angle in degrees')

    @classmethod
    def getQ(cls, phi):
        """
        Returns rotation matrix corresponding to angle phi
        """
        q = numpy.array([[numpy.cos(phi), -numpy.sin(phi)],
                         [numpy.sin(phi), numpy.cos(phi)]])
        return q

    @classmethod
    def getAngle(cls, q):
        """
        Returns angle corresponding to the rotation matrix specified by arg q
        """
        
        res = numpy.arctan2(q[1,0], q[0,0])
        return res

    def getAlpha(self):
        """
        Returns angle alpha corresponding to rotation matrix self.u
        """
        return self.getAngle(q=self.u)

    def getP(self, parity):
        """
        Returns parity matrix corresponding to arg parity. 
        """
        p = numpy.identity(2)
        if parity == 1:
            pass
        elif parity == -1:
            p[self.parity_axis, self.parity_axis] = -1
        else:
            raise ValueError("Parity can be either 1 or -1.")
        return p

    def getShear(self):
        """
        Shear
        """
        try:
            mm = self.m
        except AttributeError:
            self.decompose(order='qpsm')
        res = self.m[0, 1]
        return res

    shear = property(fget=getShear, doc='Shear')

    @classmethod
    def getM(cls, shear):
        """
        Returns share matrix corresponding to (arg) shear.
        """
        m = numpy.array([[1, shear], 
                         [0, 1]])
        return m

    ##############################################################
    #
    # Finding and applying transformations
    #

    @classmethod
    def find(cls, x, y, x_ref='cm', y_ref='cm', type_='gl'):
        """
        Finds affine transformation (general linear transformation folowed by a
        translation) that minimizes square error for transforming points x to 
        points y in 2D. The transformation has the form

          y = gl x + d,                                            (1)

        and:
 
          gl = q s p m   for type_='gl'
          gl = S q p     for type_='rs'
 
        where d is translation vector, q, s, p and m are rotation, scaling,
        parity and shear matrices, respectivly and S is a scalar scale (same
        for both directions)

        In the default mode (x_ref='cm' and y_ref='cm') the parameters are
        calculated by minimizing square error to get gl from:

          y - y_cm = gl (x - x_cm)   and   d = y_cm - gl x_cm

        where x_cm and y_cm are the centers of mass for x and y respectivly.
        In this case the square error of eq 1 is minimized

        In case args x_ref and y_ref are coordinates, gl is determined by
        minimizing square error in:

          y - y_ref = gl (x - x_ref)   and d = y_ref - gl x_ref

        Note that in this case the parameters found do not minimize the error
        of eq 1.

        In case type_='gl', general linear transformation (matrix gl) is
        calculated using Affine.find which in turn uses scipy.linalg.lstsq.

        Alternatively, if type_='rs', rotation angle parity and scale are
        calculated directly so that the square error is minimized using 
        findRS() method.

        Arguments:
          - x, y: sets of points, both having shape (n_points, n_dim)
          - x_ref, y_ref: (ndarray) coordinates of reference points, or 'cm' to
          use center of mass

        Returns the transformation found as an instance of class cls, with 
        following attributes:
          - gl: general linear transformation matrix
          - d: translation vector
          - q, p, s, m: rotation, parity, scale and shear matrices 
          - error: difference between y and transformed x values
          - resids, rank, singular: values returned from scipy.linalg.lstsq
          - _xPrime: x - x_ref
          - _yPrime: y - y_ref
          - type_: type of the optimization, 'gl' to find Gl transformation
          that optimizes the square error, or 'rs' to find the best rotation 
          and one scale (currently implemented for 2D transformations only)
        """

        if type_ == 'gl':

            # run Affine.base and doncast
            base_inst = cls.__base__.find(x=x, y=y, x_ref=x_ref, y_ref=y_ref)
            inst = cls.downcast(affine=base_inst)

        elif type_ == 'rs':

            # call special method for 'rs' type in 2D
            inst = cls.findRS(x=x, y=y, x_ref=x_ref, y_ref=y_ref)

        else:
            raise ValueError("Argument type_: ", type_, "was not ",
                             "understood. Valid values are 'gl', and 'rs'.")

        return inst

    @classmethod
    def findRS(cls, x, y, x_ref='cm', y_ref='cm'):
        """
        Finds transformation consisting of rotation, single scale factor and
        translation in 2D that minimizes square error for transforming points
        x to points y. The transformation has the form

          y = gl x + d,    gl = S q p                                     (1)
 
        where d is translation vector, q and p are rotation and parity 
        matrices, respectivly and S is a scalar scale (same for both 
        directions)

        In the default mode (x_ref='cm' and y_ref='cm') the parameters are
        calculated by minimizing square error to get gl from:

          y - y_cm = gl (x - x_cm)   and   d = y_cm - gl x_cm

        where x_cm and y_cm are the centers of mass for x and y respectivly.
        In this case the square error of eq 1 is minimized

        In case args x_ref and y_ref are coordinates, gl is determined by
        minimizing square error in:

          y - y_ref = gl (x - x_ref)   and d = y_ref - gl x_ref

        Note that in this case the parameters found do not minimize the error
        of eq 1.

        Rotation angle parity and scale are calculated directly so that the 
        square error is minimized using findRS() method.

        Arguments:
          - x, y: sets of points, both having shape (n_points, n_dim)
          - x_ref, y_ref: (ndarray) coordinates of reference points, or 'cm' to
          use center of mass

        Returns the transformation found as an instance of class cls, with 
        following attributes:
          - gl: general linear transformation matrix
          - d: translation vector
          - q, p, s, m: rotation, parity, scale and shear matrices 
          - error: difference between y and transformed x values
          - resids, rank, singular: values returned from scipy.linalg.lstsq
          - _xPrime: x - x_ref
          - _yPrime: y - y_ref
        """

        # do gl first
        base_inst = cls.__base__.find(x=x, y=y, x_ref=x_ref, y_ref=y_ref)

        # cast to this class
        inst = cls()
        inst._xPrime = base_inst._xPrime
        inst._yPrime = base_inst._yPrime
        inst.d = base_inst.d

        # find parity and scale
        det_xy = linalg.det(numpy.dot(inst._xPrime.transpose(), inst._yPrime))
        det_xx = linalg.det(numpy.dot(inst._xPrime.transpose(), inst._xPrime))
        parity = numpy.sign(det_xy * det_xx)
        scale = numpy.sqrt(parity * det_xy / float(det_xx))
        p = numpy.array([[1, 0], [0, parity]])
        s = numpy.diag([scale, scale])

        # find phi
        px = numpy.inner(inst._xPrime, p)
        ypx = (inst._yPrime * px).sum()
        s2 = numpy.array([[0, -1], [1, 0]])
        ys2px = (numpy.dot(inst._yPrime, s2) * px).sum()
        phi = numpy.arctan(-ypx / float(ys2px)) + numpy.pi / 2

        # q (rotation matrix)
        q = numpy.array([[numpy.cos(phi), -numpy.sin(phi)],
                        [numpy.sin(phi), numpy.cos(phi)]])

        # check +pi ambiguity of phi
        yqpx = (numpy.dot(inst._yPrime, q) * numpy.inner(inst._xPrime, p)).sum()
        if yqpx < 0:
            phi += numpy.pi
            q = cls.getQ(phi)
 
        # get error
        gl = numpy.dot(numpy.dot(q, s), p)
        inst.error = inst._yPrime - numpy.inner(inst._xPrime, gl)
 
        # save transformations
        inst.q = q
        inst.s = s
        inst.p = p
        inst.m = numpy.identity(2)
        inst.gl = gl
   
        return inst

    def findConformal(cls, x, y, x_mask=None, y_mask=None, d=None):
        """
        Work in progress
        
        Finds conformal transformation (global scaling and rotation folowed by a
        translation) that transforms points x to points y:

          y = s q x + d

        The scale and rotation angle are determined from averages of lengths and
        angles respectivly, of vectors formed by x and y in respect to their
        centers of mass.

        The translation is calculated translation from:

          d = y_cm - gl x_cm

        where x_cm and y_cm are x and y centers of mass.
    
        If d (translation) is given the transformation is determined using 
        given d.

        Only the points that are not masked neither in x_mask nor in y_mask are
        used.

        Arguments:
          - x, y: sets of points, both having shape (n_points, n_dim)
          - x_mask, y_masks: masked (not used) points, vectors of length 
          n_points
          - d: translation vector of length ndim

        Returns an instance of the transformation found with following 
        attributes:
          - gl: transformation matrix
          - d: translation vector
        """

        # remove masked points
        [x, y], mask = cls.removeMasked([x,y], [x_mask,y_mask])

        # deal with mode
        if d is None:

            # bring x and y to cm frame
            x_cm = numpy.mean(x, axis=0)
            x_0 = x - x_cm
            y_cm = numpy.mean(y, axis=0)
            y_0 = y - y_cm

        else:
            x_0 = x
            y_0 = y - d

        # find scale
        x_dist = Points(x_0).distance()
        y_dist = Points(y_0).distance()
        scale = (y_dist / x_dist).mean()

        # find rotation
        numpy.arctan2(y_0, x_0)
